
1、策略模式：
    原理：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象，原则就是：分离变化部分，封装接口，基于接口编程各种功能。
    此模式让行为算法的变化独立于算法的使用者。

    需要新的设计模式，应对项目的扩展性，降低复杂度
        1）分析项目变化与不变的部分，提取变化部分，抽象成接口+实现
        2）鸭子那些功能是根据新需求变化的？ 叫声、飞行。。。
        3)好处：新增行为更加方便，并且复用性好

    注意点：
        1）分析项目中变化部分（当前存在的变化部分以及后期迭代可能存在的变化）与不变化部分
        2）多用组合少用继承；用行为类的组合，而不是行为的继承（继承会使父类的影响扩展到所有的子类），更有弹性
        3）有些库或框架本身就用某种设计模式设计的



2、观察者模式（就像定牛奶业务、订报纸等）
        1）奶站（Subject）<interface>
            登记注册、移除、通知
               RegisterObServer、RemoveObserver、nodifyObservers
        2）用户（ObServer）<interface>
             接收输入
               update

    适用场景：对象之间多对一依赖的一种方案，被依赖的对象为Subject，依赖的对象为Observer，Subject通知Observer变化

    java内置观察者： Observable (class)    -- 被依赖者(由于不是接口，所以有单继承的限制)
                     Observer(interface)  -- 依赖者


3、装饰者模式
    原理：动态的将新功能附加到对象（主体）上，在对象功能扩展方面，它比继承更有弹性，也体现了开放关闭原则

    类似于打包快递
     1）主体(Component(接口、抽象)、ConcreteCompoent（具体的主体）)：陶瓷、衣服
     2）包装(Decorator(装饰者))：报纸填充、塑料泡沫、纸板、木板


    java里的装饰者模式：IO
    例如：
        主体：InputStream（超类）
        具体主体：FileInputStream、StringBufferInputStream、ByteArrayInputStream等
        装饰者（中间层）：FilterInputStream
        装饰者具体类：BufferInputStream、DataInputStream、LineNumberInputStream等


4、单例模式
    使用场景：只需要一个对象，比如线程池、缓存、硬件设备等
    原理：确保一个类只有一个对象，并提供一个全局访问点
    方式：
        1、普通懒汉式（线程不安全）
        2、双检锁懒汉式（线程安全）
        3、静态内部类方式
        4、枚举方式

5、工厂模式
    简单工厂模式：定义一个创建对象的类，由这个类封装实例化对象的行为
    工厂方法模式:定义了一个创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式将对象的实例化推迟到子类
    抽象工厂模式:定义一个接口用于创建相关或有依赖关系的对象族，而无需明确指定的具体类

    依赖抽象原则：
        1）不要让变量持有具体类的引用
        2）不要让类继承具体类，要继承抽象类或实现接口
        3）不要覆盖超类中已实现的方法，如果设计的超类中的已实现的方法出现被子类覆盖的情况，则说明该超类设计的不合理
